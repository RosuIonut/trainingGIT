/***************************************************************************
*=====================      Copyright by Continental AG      ===============
****************************************************************************
* Title        : aril1ca.cpp
*
* Description  : This is the adaption file for aril
*
* Environment  : Independent
*
* Responsible  : Todor Valchev
*
* Guidelines   : SMK 4.6
*
* Template name: C++
*
* CASE-Tool    :
*
****************************************************************************/

/* System-headerfiles */
#include  "cdef.h"
#include "cpcont_hmi_smcbgen.h"
#include "wsis_configuration.hpp"
#include "WAS_Framework.hpp"

/* Own Headerfiles */
#include "aril1ca.hpp"

// START @TiGehr: 160620 - Prototype implementation for HMI dependencies
#include "cpcont_hmi_compcbgen.h"
extern "C"
{
#include "eed_c1.h"
#include "rsst_c1.h"
#include "crhdl_c1.h"
//#include "unit_c1.h"


}
#include "hmi_c1.h"

#if (TRACE_DEBUG_available == Yes)
#include "SKIN_genTraceInterface.h"
#endif
// END @TiGehr: 160620 - Prototype implementation for HMI dependencies

// configuration table for mapping of eeprom values and theme ID
static const HMI__tenSkinMode HMI__raenSkinningMapping[HMI__nMaxSkinningMode][HMI__nMaxTubeMode] =
{
     {HMI__nenCoreCore,  HMI__nenInvalidSkinMode,  HMI__nenInvalidSkinMode,  HMI__nenSportCore,  HMI__nenInvalidSkinMode, HMI__nenCoreCore},
     {HMI__nenInvalidSkinMode, HMI__nenInvalidSkinMode, HMI__nenInvalidSkinMode, HMI__nenInvalidSkinMode, HMI__nenInvalidSkinMode, HMI__nenInvalidSkinMode},
     {HMI__nenInvalidSkinMode, HMI__nenInvalidSkinMode, HMI__nenInvalidSkinMode, HMI__nenSportPartikel, HMI__nenInvalidSkinMode, HMI__nenLifeStylePartikel}
};


/* Foreign Headerfiles */

/***************************************************************************
 * External function declarations
 ****************************************************************************/

/* =============== event callbacks =============== */

//Implementation of functions generated by proseco
// For the init/deinit functionality we do not react on the signals directly
// but implement a state machine that executes the code in its transitions
// but the XDH generator does not allow to not generate the handlers, so
// we stub them to be able to link. This is also the reason why they'll be disabled from the
// CTC coverage measurements

#ifdef __CTC__
#pragma CTC SKIP  /* avoid CTC++ path warning. See above for explanation */
#endif /* __CTC__ */

bool HMI_SM_Callbacks::boSignalSI_EV_CRHDL_InitRES_HMI_Framwork_ANY(char *pcUserData, size_t tsSize) {return true;}
bool HMI_SM_Callbacks::boSignalSI_EV_CRHDL_DeinitRES_HMI_Framwork_ANY(char *pcUserData, size_t tsSize) {return true;}
bool HMI_SM_Callbacks::boSignalSI_EV_CRHDL_InitRES_HMI_Environment_ANY(char *pcUserData, size_t tsSize) {return true;}
bool HMI_SM_Callbacks::boSignalSI_EV_CRHDL_DeinitRES_HMI_Environment_ANY(char *pcUserData, size_t tsSize) {return true;} // to exit svc

// START @TiGehr: 160620 - Prototype implementation for HMI dependencies
void HMIA_vChangeHmiDependencies(void);
void HMI_vSetHmiDependencies(void);
void HMIA_vSetHmiThemeDependency(void);

/* Signal boSignalSI_EV_DiagUpdateDisplayOffset is not needed in HUD2G+Redesign - GVK-1615 */

bool HMI_Comp_Callbacks::boSignalSI_IPC_Timeout(char *pcUserData, size_t tsSize)
{
    CC_IPC::enTimer_t ulTimerId = CC_IPC::IPC_nenNumOfTimers;

    const bool boValidData = m_oSignals.boGetUserDataTimeout(pcUserData, ulTimerId);

    if(boValidData)
    {
        if(CC_IPC::TI_KH_TimeoutTimer == ulTimerId)
        {
            HMI::WAS::Framework::PostMessage(HMI::WRS::MSG_ID_KHTIMER_TIMEOUT, HMI::WCS::DIRECT_MESSAGE, 0);
        }
        //start HACK - VAGF-29956
        //if(CC_IPC::TI_ANIMA_PSO_Timer == ulTimerId)
        //{
        //    //send addressable message to RSCC
        //    HMI::WAS::Framework::PostMessage(HMI::WRS::MSG_ID_PSOANIM_TIMEOUT, HMI::WRS::Widget_FPK_root);
        //}
        //end HACK - VAGF-29956
    }
    return True;    // should always return true, otherwise the thread is stopped
}

bool HMI_Comp_Callbacks::boSignalSI_EV_DiagAdaption_0_Change(char *pcUserData, size_t tsSize)
{
    /* ----- HMI INT TEST CODE START ----- */
    TT_vTraceEvent(TT_boSignalSI_EV_DiagAdaption_0_Change);
    /* ----- HMI INT TEST CODE END   ----- */

    HMIA_vChangeHmiDependencies();
    return true;
}

bool HMI_Comp_Callbacks::boSignalSI_EV_DiagCodingChange(char *pcUserData, size_t tsSize)
{
    /* ----- HMI INT TEST CODE START ----- */
    TT_vTraceEvent(TT_boSignalSI_EV_DiagCodingChange);
    /* ----- HMI INT TEST CODE END   ----- */

    HMIA_vChangeHmiDependencies();
    return true;
}

bool HMI_Comp_Callbacks::boSignalSI_EV_DPOOL_OnChange_M_Language(char *pcUserData, size_t tsSize)
{
    /* ----- HMI INT TEST CODE START ----- */
    TT_vTraceEvent(TT_boSignalSI_EV_DPOOL_OnChange_M_Language);
    /* ----- HMI INT TEST CODE END   ----- */

    HMIA_vChangeHmiDependencies();
    return true;
}

bool HMI_Comp_Callbacks::boSignalSI_EV_DPOOL_OnChange_BAPA_mHUDColour_Valid(char *pcUserData, size_t tsSize)
{
    HMIA_vSetHmiThemeDependency();
    return true;
}

bool HMI_Comp_Callbacks::boSignalSI_EV_CRHDL_InitRES_HMI_Framwork_ANY(char *pcUserData, size_t tsSize)
{
    /* ----- HMI INT TEST CODE START ----- */
    TT_vTraceEvent(TT_boSignalSI__InitRES_HMI_Framwork_ANY);
    /* ----- HMI INT TEST CODE END   ----- */

    HMI_vSetHmiDependencies();

    //Register signal for skin change
    CC_IPC::CSignals::veSignalIdList_t veSignals;
    veSignals.push_back(CC_IPC::SI_EV_DPOOL_OnChange__hmi_skin_download_byGraBoot);
    m_oSignals.boSendIPCRegistration(veSignals);

    return true;
}

bool HMI_Comp_Callbacks::boSignalSI_EV_CRHDL_DeinitRES_HMI_Framwork_ANY(char *pcUserData, size_t tsSize)
{
    //De-register signal for skin change
    CC_IPC::CSignals::veSignalIdList_t veSignals;
    veSignals.push_back(CC_IPC::SI_EV_DPOOL_OnChange__hmi_skin_download_byGraBoot);
    m_oSignals.boSendIPCDeregistration(veSignals);

    return true;
}

//Receive signal which is sent from GraBoot: New skin is downloaded
bool  HMI_Comp_Callbacks::boSignalSI_EV_DPOOL_OnChange__hmi_skin_download_byGraBoot(char *pcUserData, size_t tsSize)
{
    HMIA_vSetHmiThemeDependency();

    return true;
}

//Function is called by GraBoot to get current skin
uint8 HMIA_u8GetHMISkin()
{

    uint8 u8SkinningMode = EEH_u8GetSkinning();
    uint8 u8TubeMode = EEH_u8Getda_tuben_darstellung();
    /* DaCa: ToDo Check source for skinning in EEPROM - needed only for VW
    DPOOL_txEED__tstICOM_EEDDataMsg_RACW1   stEEDDataRACW1 = { 0 };

    DPOOL_enGetPoolData(DPOOL_nDataEED__stICOM_EEDDataMsg_RACW1, &stEEDDataRACW1);
    uint8 u8SkinningMode = stEEDDataRACW1.Skinning;
    uint8 u8TubeMode = stEEDDataRACW1.da_tuben_darstellung;
    */
    uint8 u8Skin = 0;

    if ((u8SkinningMode < HMI__nMaxSkinningMode) && (u8TubeMode < HMI__nMaxTubeMode))
    {
        u8Skin = HMI__raenSkinningMapping[u8SkinningMode][u8TubeMode];
    }

    if ((u8Skin < HMI__nenInvalidSkinMode) && RSST_boIsDepAvailable(NULL, RSST_nDep_Theme, u8Skin))
    {
        return u8Skin;
    }

    return 0;
}


void HMIA_vSetHmiThemeDependency(void)
{
    /*
    uint8 u8SkinningMode = EEH_u8GetSkinning();
    uint8 u8TubeMode = EEH_u8Getda_tuben_darstellung();
    uint8 u8Skin = 0;

    if ((u8SkinningMode < HMI__nMaxSkinningMode) && (u8TubeMode < HMI__nMaxTubeMode))
    {
        u8Skin = (u8SkinningMode*HMI__nMaxSkinningMode) + u8TubeMode;
    }

    if (RSST_boIsDepAvailable(NULL, RSST_nDep_Theme, u8Skin))
    {
        HMI_boSetDependency(RSST_nDep_Theme, (RSST_tenThemeID)u8Skin);
    }
    else
    {
        HMI_boSetDependency(RSST_nDep_Theme, (RSST_tenThemeID)0);
    }
    */
    BAPA_tstHUDColour stColour;
    /* Get loaded skin */
    DPOOL_enGetPoolData(DPOOL_nDataBAPA_mHUDColour_Valid, &stColour);

    if (CRHDL_nStateOn == CRHDL_enStateHdlGetState(CRHDL_nSMRES_SyncBoot))
    {
        if (RSST_boIsDepAvailable(NULL, RSST_nDep_Theme, stColour.biColour))
        {
            HMI_boSetDependency(RSST_nDep_Theme, (RSST_tenThemeID)stColour.biColour);
        }
        else
        {
            HMI_boSetDependency(RSST_nDep_Theme, (RSST_tenThemeID)0);
        }
    }
    else
    {
        /* Graphic resources are not yet available */
    }
}

void HMIA_vSetHmiLanguageDependency(void)
{

    uint8 u8Language = 0;
    uint8 u8ApiLanguage = 0;
    DPOOL_enGetPoolData(DPOOL_nDataM_Language, &u8Language);
    /* ----- HMI INT TEST CODE START ----- */
    TT_vTraceEvent(TT_GetDPOOL_M_Language, (uint16)u8Language);
    /* ----- HMI INT TEST CODE END   ----- */
    /* EasyCASE > */
    if (u8Language < RSST_nLang_NumEntries)
    {
        if (/* is language settable */
            RSST_boIsDepAvailable(NULL, RSST_nDep_Language, u8Language))
        {
            u8ApiLanguage = u8Language;
        }
        else
        {
            u8ApiLanguage = (uint8)EEH_biGetp_codierung_einheit_sprache();
        }
        DPOOL_enSetPoolData(DPOOL_nDataGRAU_u8ApiDataLanguage, &u8ApiLanguage);
        HMI_boSetDependency(RSST_nDep_Language, (RSST_tenLanguageID)u8ApiLanguage);
    }
}


void HMI_vSetHmiDependencies(void)
{
    RSST_tenDependentType enDepType = RSST_nDep_Language;
    uint8 u8ClusterDerivatInfo = EEH_u8Getp_markeninfo();
    uint8 u8ClusterVariantAsia = (uint8)EEH_boGetp_kombi_variante_asien() ? 1 : 0;
    //uint8 u8AnimLayerOpaqueness = EEH_u8GetAnimLayerOpaqueness();


    //DPOOL_enSetPoolData(DPOOL_nDataGRAU_u8AnimLayerOpaqueness, &u8AnimLayerOpaqueness);
    for (uint8 i = (uint8)enDepType; i < RSST_nDep_NumEntries; i++)
    {
        switch ((RSST_tenDependentType)i)
        {
        case RSST_nDep_Language:
            HMIA_vSetHmiLanguageDependency();
            break;
        case RSST_nDep_Brand:
            HMI_boSetDependency(RSST_nDep_Brand, 0); // Kr Patch for missing initialization of Brand
            /* not implemented */
            break;
        case RSST_nDep_DefaultLanguage:
            HMI_boSetDependency((RSST_tenDependentType)i, (RSST_tenDefaultLanguageID)EEH_biGetp_codierung_einheit_sprache());
            break;
        case RSST_nDep_Theme:
            HMIA_vSetHmiThemeDependency();
            break;
        default:
            break;
        }
    }
}

#if (TRACE_DEBUG_available == Yes)

/* trace command 'SelectSkin' */
TRACE_tCmdReturnCode SKIN_xTraceCmdSelectSkin(uint8 skinId)
{
    HMI_boSetDependency(RSST_nDep_Theme, skinId);
    return TRACE_nCMDRETVAL_OK;
}

/* trace command 'SelectLanguage' */
TRACE_tCmdReturnCode SKIN_xTraceCmdSelectLanguage(uint8 languageId)
{
    HMI_boSetDependency(RSST_nDep_Language, languageId);
    return TRACE_nCMDRETVAL_OK;
}
#endif //#if (TRACE_DEBUG_available == Yes)

void HMIA_vChangeHmiDependencies(void)
{
    CRHDL_tenSMState enSMState0 = CRHDL_enStateHdlGetState(CRHDL_nSMRES_HMI_Environment);
    CRHDL_tenSMState enSMState1 = CRHDL_enStateHdlGetState(CRHDL_nSMRES_SyncBoot);
	
	/* ----- HMI INT TEST CODE START ----- */
    TT_vTraceEvent(TT_CRHDL_enStateHdlGetState, (uint16)(enSMState0&&enSMState1));
    /* ----- HMI INT TEST CODE END   ----- */


    if (/* only in system state RES_HMI_Environment & RES_SyncBoot are ON */
        (enSMState0 == CRHDL_nStateOn) && (enSMState1 == CRHDL_nStateOn)
        )
    {
        //HMIA_vSetHmiThemeDependency(); //Skin change should be processed on signal from GraBoot
        HMI_boSetDependency(RSST_nDep_DefaultLanguage, (RSST_tenDefaultLanguageID)EEH_biGetp_codierung_einheit_sprache());
        HMIA_vSetHmiLanguageDependency();
    }
}

// END @TiGehr: 160620 - Prototype implementation for HMI dependencies



#if ( (WSIS_PLATFORM == WSIS_PLATFORM_ACE) && (WSIS_PLATFORM_VARIANT == WSIS_PLATFORM_ACEonAROS) )

extern "C" {
#include "evhd_c1.h"

//------------------------------------------------------------------------------
// Fake CSC
// translates resource on/off events into CSC events
void FakeCSC_vEventHandler (const EVHD_tenReceiveEvent enEvent)
{
    switch (enEvent)
    {
     case EV_OnSReqSMRES_HMI_Environment_FakeCSC_vEventHandler  :   EVHD_vSendEvent(EV_CRHDL_InitRES_HMI_Environment_ANY);   break;
     case EV_OnSReqSMRES_HMI_Framwork_FakeCSC_vEventHandler    :   EVHD_vSendEvent(EV_CRHDL_InitRES_HMI_Framwork_ANY);     break;
     case EV_OffSReqSMRES_HMI_Environment_FakeCSC_vEventHandler  :   EVHD_vSendEvent(EV_CRHDL_DeinitRES_HMI_Environment_ANY); break;
     case EV_OffSReqSMRES_HMI_Framwork_FakeCSC_vEventHandler    :   EVHD_vSendEvent(EV_CRHDL_DeinitRES_HMI_Framwork_ANY);   break;
    }
} // FakeCSC_vEventHandler
} // extern "C"

#endif // ( (WSIS_PLATFORM == WSIS_PLATFORM_ACE) && (WSIS_PLATFORM_VARIANT == WSIS_PLATFORM_ACEonAROS) )



#ifdef __CTC__
#pragma CTC ENDSKIP
#endif /* __CTC__ */
